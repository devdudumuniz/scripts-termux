#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
DMTech Termux Pentest - Export Utilities
Módulo para exportação de resultados em JSON e CSV
"""

import os
import json
import csv
from datetime import datetime
from pathlib import Path
from typing import Dict, List, Any, Optional

class DataExporter:
    """Gerenciador de exportação de dados"""
    
    def __init__(self, output_dir: str = "output"):
        self.output_dir = Path(output_dir)
        self.json_dir = self.output_dir / "json"
        self.csv_dir = self.output_dir / "csv"
        
        # Criar diretórios se não existirem
        self.json_dir.mkdir(parents=True, exist_ok=True)
        self.csv_dir.mkdir(parents=True, exist_ok=True)
    
    def export_json(self, data: Any, filename: str, 
                   include_timestamp: bool = True) -> str:
        """
        Exporta dados em formato JSON
        
        Args:
            data: Dados a serem exportados
            filename: Nome do arquivo (sem extensão)
            include_timestamp: Se True, adiciona timestamp ao nome do arquivo
            
        Returns:
            Caminho completo do arquivo gerado
        """
        if include_timestamp:
            timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
            filename = f"{filename}_{timestamp}"
        
        filepath = self.json_dir / f"{filename}.json"
        
        try:
            with open(filepath, 'w', encoding='utf-8') as f:
                json.dump(data, f, indent=2, ensure_ascii=False)
            
            return str(filepath)
        
        except Exception as e:
            raise Exception(f"Erro ao exportar JSON: {e}")
    
    def export_csv(self, data: List[Dict[str, Any]], filename: str,
                  include_timestamp: bool = True,
                  fieldnames: Optional[List[str]] = None) -> str:
        """
        Exporta dados em formato CSV
        
        Args:
            data: Lista de dicionários a serem exportados
            filename: Nome do arquivo (sem extensão)
            include_timestamp: Se True, adiciona timestamp ao nome do arquivo
            fieldnames: Lista de campos a incluir (None = todos)
            
        Returns:
            Caminho completo do arquivo gerado
        """
        if not data:
            raise ValueError("Dados vazios para exportação CSV")
        
        if include_timestamp:
            timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
            filename = f"{filename}_{timestamp}"
        
        filepath = self.csv_dir / f"{filename}.csv"
        
        # Determinar fieldnames se não fornecido
        if fieldnames is None:
            fieldnames = list(data[0].keys())
        
        try:
            with open(filepath, 'w', newline='', encoding='utf-8') as f:
                writer = csv.DictWriter(f, fieldnames=fieldnames)
                writer.writeheader()
                
                for row in data:
                    # Filtrar apenas os campos especificados
                    filtered_row = {k: v for k, v in row.items() if k in fieldnames}
                    writer.writerow(filtered_row)
            
            return str(filepath)
        
        except Exception as e:
            raise Exception(f"Erro ao exportar CSV: {e}")
    
    def export_both(self, data: Any, filename: str,
                   include_timestamp: bool = True) -> Dict[str, str]:
        """
        Exporta dados em JSON e CSV simultaneamente
        
        Args:
            data: Dados a serem exportados
            filename: Nome base do arquivo
            include_timestamp: Se True, adiciona timestamp ao nome
            
        Returns:
            Dicionário com caminhos dos arquivos gerados
        """
        results = {}
        
        # Exportar JSON
        try:
            json_path = self.export_json(data, filename, include_timestamp)
            results['json'] = json_path
        except Exception as e:
            results['json_error'] = str(e)
        
        # Exportar CSV (se os dados forem uma lista de dicts)
        if isinstance(data, list) and data and isinstance(data[0], dict):
            try:
                csv_path = self.export_csv(data, filename, include_timestamp)
                results['csv'] = csv_path
            except Exception as e:
                results['csv_error'] = str(e)
        else:
            results['csv_note'] = "Dados não compatíveis com formato CSV"
        
        return results
    
    def export_scan_results(self, tool_name: str, results: Dict[str, Any],
                          metadata: Optional[Dict[str, Any]] = None) -> Dict[str, str]:
        """
        Exporta resultados de scan com metadados
        
        Args:
            tool_name: Nome da ferramenta
            results: Resultados do scan
            metadata: Metadados adicionais (parâmetros, timestamp, etc.)
            
        Returns:
            Dicionário com caminhos dos arquivos gerados
        """
        # Preparar dados completos
        export_data = {
            "tool": tool_name,
            "timestamp": datetime.now().isoformat(),
            "metadata": metadata or {},
            "results": results
        }
        
        # Nome do arquivo baseado na ferramenta
        filename = f"{tool_name.lower().replace(' ', '_')}_scan"
        
        return self.export_both(export_data, filename)
    
    def export_host_list(self, hosts: List[Dict[str, Any]], 
                        scan_type: str = "network") -> Dict[str, str]:
        """
        Exporta lista de hosts descobertos
        
        Args:
            hosts: Lista de hosts com informações
            scan_type: Tipo de scan realizado
            
        Returns:
            Dicionário com caminhos dos arquivos gerados
        """
        filename = f"{scan_type}_hosts"
        return self.export_both(hosts, filename)
    
    def export_port_scan(self, target: str, ports: List[Dict[str, Any]]) -> Dict[str, str]:
        """
        Exporta resultados de scan de portas
        
        Args:
            target: IP ou hostname alvo
            ports: Lista de portas descobertas
            
        Returns:
            Dicionário com caminhos dos arquivos gerados
        """
        data = {
            "target": target,
            "timestamp": datetime.now().isoformat(),
            "total_ports": len(ports),
            "ports": ports
        }
        
        filename = f"portscan_{target.replace('.', '_')}"
        return self.export_both(data, filename)
    
    def list_exports(self, format_type: str = "all") -> List[str]:
        """
        Lista arquivos exportados
        
        Args:
            format_type: Tipo de formato ('json', 'csv', 'all')
            
        Returns:
            Lista de caminhos de arquivos
        """
        files = []
        
        if format_type in ["json", "all"]:
            files.extend([str(f) for f in self.json_dir.glob("*.json")])
        
        if format_type in ["csv", "all"]:
            files.extend([str(f) for f in self.csv_dir.glob("*.csv")])
        
        return sorted(files, key=lambda x: os.path.getmtime(x), reverse=True)


# Instância global do exporter
_exporter_instance = None

def get_exporter() -> DataExporter:
    """Retorna a instância global do exporter"""
    global _exporter_instance
    if _exporter_instance is None:
        _exporter_instance = DataExporter()
    return _exporter_instance
