#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Port Scanner Básico - Sem privilégios ROOT
Scanner de portas com multithreading otimizado para dispositivos móveis

PRÉ-REQUISITOS:
    - Python 3.x
    - Nenhuma biblioteca externa necessária

USO:
    ./portscan_basic.py <target> [--ports <ports>] [--threads <num>]
    
    Exemplos:
        ./portscan_basic.py 192.168.1.1
        ./portscan_basic.py 192.168.1.1 --ports 1-1000
        ./portscan_basic.py 192.168.1.1 --ports 80,443,8080 --threads 50
"""

import socket
import sys
import json
import csv
import argparse
from datetime import datetime
from concurrent.futures import ThreadPoolExecutor, as_completed
from pathlib import Path

# Cores para terminal
class Colors:
    RED = '\033[0;31m'
    GREEN = '\033[0;32m'
    YELLOW = '\033[1;33m'
    CYAN = '\033[0;36m'
    NC = '\033[0m'

# Portas comuns para scan rápido
COMMON_PORTS = [
    21, 22, 23, 25, 53, 80, 110, 111, 135, 139, 143, 443, 445, 
    993, 995, 1723, 3306, 3389, 5900, 8000, 8080, 8443, 8888
]

# Mapeamento de serviços
SERVICE_MAP = {
    21: 'FTP', 22: 'SSH', 23: 'Telnet', 25: 'SMTP', 53: 'DNS',
    80: 'HTTP', 110: 'POP3', 111: 'RPC', 135: 'MSRPC', 139: 'NetBIOS',
    143: 'IMAP', 443: 'HTTPS', 445: 'SMB', 993: 'IMAPS', 995: 'POP3S',
    1723: 'PPTP', 3306: 'MySQL', 3389: 'RDP', 5432: 'PostgreSQL',
    5900: 'VNC', 8000: 'HTTP-Alt', 8080: 'HTTP-Proxy', 8443: 'HTTPS-Alt',
    8888: 'HTTP-Alt', 554: 'RTSP', 1935: 'RTMP', 5000: 'UPnP'
}

class PortScanner:
    """Scanner de portas com multithreading"""
    
    def __init__(self, target, ports, threads=20, timeout=2):
        self.target = target
        self.ports = ports
        self.threads = threads
        self.timeout = timeout
        self.open_ports = []
        
    def scan_port(self, port):
        """Escaneia uma porta específica"""
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(self.timeout)
            result = sock.connect_ex((self.target, port))
            sock.close()
            
            if result == 0:
                service = SERVICE_MAP.get(port, 'Unknown')
                banner = self.grab_banner(port)
                
                return {
                    'port': port,
                    'state': 'open',
                    'service': service,
                    'banner': banner if banner else 'N/A'
                }
            return None
            
        except Exception:
            return None
    
    def grab_banner(self, port, timeout=1):
        """Tenta capturar banner do serviço"""
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(timeout)
            sock.connect((self.target, port))
            
            # Tentar receber dados
            banner = sock.recv(1024).decode('utf-8', errors='ignore').strip()
            sock.close()
            
            return banner if banner else None
            
        except Exception:
            return None
    
    def scan(self):
        """Executa o scan de todas as portas"""
        print(f"{Colors.CYAN}[*]{Colors.NC} Escaneando {len(self.ports)} portas em {self.target}...")
        print(f"{Colors.CYAN}[*]{Colors.NC} Threads: {self.threads}, Timeout: {self.timeout}s\n")
        
        completed = 0
        
        with ThreadPoolExecutor(max_workers=self.threads) as executor:
            futures = {executor.submit(self.scan_port, port): port for port in self.ports}
            
            for future in as_completed(futures):
                completed += 1
                result = future.result()
                
                if result:
                    self.open_ports.append(result)
                    print(f"{Colors.GREEN}[+]{Colors.NC} {result['port']}/tcp - {result['service']} - {result['banner']}")
                
                # Mostrar progresso a cada 50 portas
                if completed % 50 == 0:
                    print(f"{Colors.YELLOW}[*]{Colors.NC} Progresso: {completed}/{len(self.ports)}")
        
        return self.open_ports

def parse_ports(port_string):
    """Parse string de portas para lista"""
    ports = []
    
    if port_string == 'common':
        return COMMON_PORTS
    
    for part in port_string.split(','):
        if '-' in part:
            start, end = map(int, part.split('-'))
            ports.extend(range(start, end + 1))
        else:
            ports.append(int(part))
    
    return sorted(set(ports))

def export_results(target, ports, output_dir='../output'):
    """Exporta resultados em JSON e CSV"""
    output_path = Path(output_dir)
    json_dir = output_path / 'json'
    csv_dir = output_path / 'csv'
    
    json_dir.mkdir(parents=True, exist_ok=True)
    csv_dir.mkdir(parents=True, exist_ok=True)
    
    timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
    target_clean = target.replace('.', '_')
    
    # JSON
    json_file = json_dir / f"portscan_{target_clean}_{timestamp}.json"
    with open(json_file, 'w', encoding='utf-8') as f:
        json.dump({
            'scan_timestamp': datetime.now().isoformat(),
            'target': target,
            'total_ports_scanned': len(COMMON_PORTS) if not ports else len(ports),
            'open_ports_count': len(ports),
            'ports': ports
        }, f, indent=2, ensure_ascii=False)
    
    # CSV
    csv_file = csv_dir / f"portscan_{target_clean}_{timestamp}.csv"
    if ports:
        with open(csv_file, 'w', newline='', encoding='utf-8') as f:
            writer = csv.DictWriter(f, fieldnames=['port', 'state', 'service', 'banner'])
            writer.writeheader()
            writer.writerows(ports)
    
    return str(json_file), str(csv_file)

def main():
    parser = argparse.ArgumentParser(
        description='Port Scanner Básico - DMTech Pentest',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Exemplos:
  %(prog)s 192.168.1.1                    # Scan portas comuns
  %(prog)s 192.168.1.1 --ports 1-1000     # Scan portas 1-1000
  %(prog)s 192.168.1.1 --ports 80,443,8080 --threads 50
        """
    )
    
    parser.add_argument('target', help='IP ou hostname alvo')
    parser.add_argument('--ports', '-p', default='common',
                       help='Portas a escanear (ex: 1-1000, 80,443,8080, common)')
    parser.add_argument('--threads', '-t', type=int, default=20,
                       help='Número de threads (padrão: 20)')
    parser.add_argument('--timeout', type=int, default=2,
                       help='Timeout em segundos (padrão: 2)')
    
    args = parser.parse_args()
    
    # Banner
    print(f"{Colors.CYAN}{'='*60}{Colors.NC}")
    print(f"{Colors.YELLOW}  Port Scanner Básico - DMTech Pentest{Colors.NC}")
    print(f"{Colors.CYAN}{'='*60}{Colors.NC}\n")
    
    # Parse portas
    ports = parse_ports(args.ports)
    
    # Criar scanner
    scanner = PortScanner(
        target=args.target,
        ports=ports,
        threads=args.threads,
        timeout=args.timeout
    )
    
    # Executar scan
    start_time = datetime.now()
    open_ports = scanner.scan()
    end_time = datetime.now()
    
    duration = (end_time - start_time).total_seconds()
    
    # Resultados
    print(f"\n{Colors.CYAN}{'='*60}{Colors.NC}")
    print(f"{Colors.GREEN}[✓]{Colors.NC} Scan concluído em {duration:.2f} segundos")
    print(f"{Colors.GREEN}[✓]{Colors.NC} Portas abertas encontradas: {len(open_ports)}")
    
    if open_ports:
        # Exportar
        json_file, csv_file = export_results(args.target, open_ports)
        print(f"\n{Colors.CYAN}[*]{Colors.NC} Resultados exportados:")
        print(f"    JSON: {json_file}")
        print(f"    CSV: {csv_file}")
    else:
        print(f"{Colors.YELLOW}[!]{Colors.NC} Nenhuma porta aberta encontrada")
    
    print(f"{Colors.CYAN}{'='*60}{Colors.NC}\n")

if __name__ == '__main__':
    try:
        main()
    except KeyboardInterrupt:
        print(f"\n{Colors.RED}[!]{Colors.NC} Scan interrompido pelo usuário")
        sys.exit(1)
    except Exception as e:
        print(f"{Colors.RED}[ERROR]{Colors.NC} {e}")
        sys.exit(1)
