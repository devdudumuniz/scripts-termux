#!/data/data/com.termux/files/usr/bin/bash
# -*- coding: utf-8 -*-
#
# Camera Finder - Localizador de câmeras IP sem ROOT
# Escaneia portas comuns de câmeras e tenta identificar dispositivos
#
# PRÉ-REQUISITOS:
#   - curl, nc (netcat)
#
# USO:
#   ./camera_finder.sh [network_cidr]
#

set -e

# Cores
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
CYAN='\033[0;36m'
NC='\033[0m'

# Configurações
NETWORK="${1:-192.168.1.0/24}"
OUTPUT_DIR="../output"
LOG_DIR="../logs"
TIMESTAMP=$(date +%Y%m%d_%H%M%S)

# Portas comuns de câmeras IP
CAMERA_PORTS=(80 554 8000 8080 8081 8888 9000)

# Criar diretórios
mkdir -p "$OUTPUT_DIR/json" "$OUTPUT_DIR/csv" "$LOG_DIR"

# Arquivo de log
LOGFILE="$LOG_DIR/camera_finder_${TIMESTAMP}.log"

# Função de log
log() {
    echo -e "${CYAN}[$(date +'%H:%M:%S')]${NC} $1" | tee -a "$LOGFILE"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1" | tee -a "$LOGFILE"
}

log_success() {
    echo -e "${GREEN}[✓]${NC} $1" | tee -a "$LOGFILE"
}

# Verificar dependências
check_deps() {
    if ! command -v curl &> /dev/null; then
        log_error "curl não instalado. Execute: pkg install curl"
        exit 1
    fi
    
    if ! command -v nc &> /dev/null; then
        log_error "netcat não instalado. Execute: pkg install netcat"
        exit 1
    fi
    
    log_success "Dependências verificadas"
}

# Scan de câmeras
scan_cameras() {
    log "Procurando câmeras IP em $NETWORK..."
    
    python3 << 'PYEOF'
import subprocess
import json
import csv
import ipaddress
import socket
import re
from datetime import datetime
from concurrent.futures import ThreadPoolExecutor, as_completed

NETWORK = "$NETWORK"
CAMERA_PORTS = [80, 554, 8000, 8080, 8081, 8888, 9000]
OUTPUT_DIR = "$OUTPUT_DIR"
TIMESTAMP = "$TIMESTAMP"
TIMEOUT = 3

def check_port(ip, port):
    """Verifica se porta está aberta"""
    try:
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.settimeout(TIMEOUT)
        result = sock.connect_ex((str(ip), port))
        sock.close()
        return result == 0
    except:
        return False

def check_http_camera(ip, port):
    """Verifica se é uma câmera via HTTP"""
    try:
        import urllib.request
        
        url = f"http://{ip}:{port}/"
        req = urllib.request.Request(url, headers={'User-Agent': 'Mozilla/5.0'})
        
        with urllib.request.urlopen(req, timeout=TIMEOUT) as response:
            content = response.read().decode('utf-8', errors='ignore').lower()
            headers = dict(response.headers)
            
            # Identificadores de câmeras
            camera_keywords = [
                'ipcam', 'webcam', 'camera', 'dvr', 'nvr', 'hikvision',
                'dahua', 'axis', 'foscam', 'vivotek', 'mobotix',
                'video surveillance', 'network camera'
            ]
            
            is_camera = any(keyword in content for keyword in camera_keywords)
            
            # Tentar identificar modelo
            model = 'Unknown'
            for keyword in camera_keywords:
                if keyword in content:
                    model = keyword.title()
                    break
            
            # Verificar server header
            server = headers.get('Server', 'Unknown')
            
            return {
                'is_camera': is_camera,
                'model': model,
                'server': server,
                'url': url
            }
    except:
        return None

def check_rtsp_camera(ip, port=554):
    """Verifica se é uma câmera RTSP"""
    try:
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.settimeout(TIMEOUT)
        sock.connect((str(ip), port))
        
        # Enviar DESCRIBE RTSP
        request = f"DESCRIBE rtsp://{ip}:{port}/ RTSP/1.0\r\nCSeq: 1\r\n\r\n"
        sock.send(request.encode())
        
        response = sock.recv(1024).decode('utf-8', errors='ignore')
        sock.close()
        
        if 'RTSP' in response:
            return {
                'is_camera': True,
                'protocol': 'RTSP',
                'url': f"rtsp://{ip}:{port}/"
            }
    except:
        pass
    
    return None

def scan_host(ip):
    """Escaneia um host procurando câmeras"""
    cameras = []
    
    for port in CAMERA_PORTS:
        if check_port(ip, port):
            camera_info = {
                'ip': str(ip),
                'port': port,
                'timestamp': datetime.now().isoformat()
            }
            
            # Verificar HTTP
            if port in [80, 8000, 8080, 8081, 8888, 9000]:
                http_info = check_http_camera(ip, port)
                if http_info and http_info.get('is_camera'):
                    camera_info.update(http_info)
                    cameras.append(camera_info)
                    print(f"[+] Câmera encontrada: {ip}:{port} - {http_info.get('model', 'Unknown')}")
            
            # Verificar RTSP
            elif port == 554:
                rtsp_info = check_rtsp_camera(ip, port)
                if rtsp_info and rtsp_info.get('is_camera'):
                    camera_info.update(rtsp_info)
                    cameras.append(camera_info)
                    print(f"[+] Câmera RTSP encontrada: {ip}:{port}")
    
    return cameras

# Expandir CIDR
network = ipaddress.ip_network(NETWORK, strict=False)
ip_list = [str(ip) for ip in network.hosts()]

print(f"Escaneando {len(ip_list)} hosts em busca de câmeras IP...")

all_cameras = []
completed = 0

with ThreadPoolExecutor(max_workers=20) as executor:
    futures = {executor.submit(scan_host, ip): ip for ip in ip_list}
    
    for future in as_completed(futures):
        completed += 1
        cameras = future.result()
        
        if cameras:
            all_cameras.extend(cameras)
        
        if completed % 10 == 0:
            print(f"[*] Progresso: {completed}/{len(ip_list)}")

# Salvar JSON
json_output = f"{OUTPUT_DIR}/json/camera_finder_{TIMESTAMP}.json"
with open(json_output, 'w', encoding='utf-8') as f:
    json.dump({
        'scan_timestamp': datetime.now().isoformat(),
        'network': NETWORK,
        'total_cameras': len(all_cameras),
        'cameras': all_cameras
    }, f, indent=2, ensure_ascii=False)

# Salvar CSV
csv_output = f"{OUTPUT_DIR}/csv/camera_finder_{TIMESTAMP}.csv"
if all_cameras:
    with open(csv_output, 'w', newline='', encoding='utf-8') as f:
        fieldnames = ['ip', 'port', 'model', 'server', 'protocol', 'url', 'timestamp']
        writer = csv.DictWriter(f, fieldnames=fieldnames, extrasaction='ignore')
        writer.writeheader()
        writer.writerows(all_cameras)

print(f"\nEncontradas {len(all_cameras)} câmeras IP")
print(f"JSON: {json_output}")
print(f"CSV: {csv_output}")
PYEOF
    
    log_success "Scan de câmeras concluído"
}

# Main
main() {
    echo -e "${CYAN}═══════════════════════════════════════════════════════════${NC}"
    echo -e "${YELLOW}  Camera Finder - DMTech Pentest${NC}"
    echo -e "${CYAN}═══════════════════════════════════════════════════════════${NC}"
    echo ""
    
    check_deps
    
    log "Alvo: $NETWORK"
    log "Portas: ${CAMERA_PORTS[*]}"
    
    scan_cameras
    
    echo ""
    log_success "Scan concluído com sucesso!"
}

main
